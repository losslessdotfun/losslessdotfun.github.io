{"version":3,"file":"778.index.bundle.js","sources":["webpack://interface/./node_modules/viem/_esm/errors/ccip.js","webpack://interface/./node_modules/viem/_esm/utils/ccip.js"],"sourcesContent":["import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nimport { getUrl } from './utils.js';\nexport class OffchainLookupError extends BaseError {\n    constructor({ callbackSelector, cause, data, extraData, sender, urls, }) {\n        super(cause.shortMessage ||\n            'An error occurred while fetching for an offchain result.', {\n            cause,\n            metaMessages: [\n                ...(cause.metaMessages || []),\n                cause.metaMessages?.length ? '' : [],\n                'Offchain Gateway Call:',\n                urls && [\n                    '  Gateway URL(s):',\n                    ...urls.map((url) => `    ${getUrl(url)}`),\n                ],\n                `  Sender: ${sender}`,\n                `  Data: ${data}`,\n                `  Callback selector: ${callbackSelector}`,\n                `  Extra data: ${extraData}`,\n            ].flat(),\n            name: 'OffchainLookupError',\n        });\n    }\n}\nexport class OffchainLookupResponseMalformedError extends BaseError {\n    constructor({ result, url }) {\n        super('Offchain gateway response is malformed. Response data must be a hex value.', {\n            metaMessages: [\n                `Gateway URL: ${getUrl(url)}`,\n                `Response: ${stringify(result)}`,\n            ],\n            name: 'OffchainLookupResponseMalformedError',\n        });\n    }\n}\nexport class OffchainLookupSenderMismatchError extends BaseError {\n    constructor({ sender, to }) {\n        super('Reverted sender address does not match target contract address (`to`).', {\n            metaMessages: [\n                `Contract address: ${to}`,\n                `OffchainLookup sender address: ${sender}`,\n            ],\n            name: 'OffchainLookupSenderMismatchError',\n        });\n    }\n}\n//# sourceMappingURL=ccip.js.map","import { call } from '../actions/public/call.js';\nimport { OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError, } from '../errors/ccip.js';\nimport { HttpRequestError, } from '../errors/request.js';\nimport { decodeErrorResult } from './abi/decodeErrorResult.js';\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js';\nimport { isAddressEqual } from './address/isAddressEqual.js';\nimport { concat } from './data/concat.js';\nimport { isHex } from './data/isHex.js';\nimport { stringify } from './stringify.js';\nexport const offchainLookupSignature = '0x556f1830';\nexport const offchainLookupAbiItem = {\n    name: 'OffchainLookup',\n    type: 'error',\n    inputs: [\n        {\n            name: 'sender',\n            type: 'address',\n        },\n        {\n            name: 'urls',\n            type: 'string[]',\n        },\n        {\n            name: 'callData',\n            type: 'bytes',\n        },\n        {\n            name: 'callbackFunction',\n            type: 'bytes4',\n        },\n        {\n            name: 'extraData',\n            type: 'bytes',\n        },\n    ],\n};\nexport async function offchainLookup(client, { blockNumber, blockTag, data, to, }) {\n    const { args } = decodeErrorResult({\n        data,\n        abi: [offchainLookupAbiItem],\n    });\n    const [sender, urls, callData, callbackSelector, extraData] = args;\n    const { ccipRead } = client;\n    const ccipRequest_ = ccipRead && typeof ccipRead?.request === 'function'\n        ? ccipRead.request\n        : ccipRequest;\n    try {\n        if (!isAddressEqual(to, sender))\n            throw new OffchainLookupSenderMismatchError({ sender, to });\n        const result = await ccipRequest_({ data: callData, sender, urls });\n        const { data: data_ } = await call(client, {\n            blockNumber,\n            blockTag,\n            data: concat([\n                callbackSelector,\n                encodeAbiParameters([{ type: 'bytes' }, { type: 'bytes' }], [result, extraData]),\n            ]),\n            to,\n        });\n        return data_;\n    }\n    catch (err) {\n        throw new OffchainLookupError({\n            callbackSelector,\n            cause: err,\n            data,\n            extraData,\n            sender,\n            urls,\n        });\n    }\n}\nexport async function ccipRequest({ data, sender, urls, }) {\n    let error = new Error('An unknown error occurred.');\n    for (let i = 0; i < urls.length; i++) {\n        const url = urls[i];\n        const method = url.includes('{data}') ? 'GET' : 'POST';\n        const body = method === 'POST' ? { data, sender } : undefined;\n        const headers = method === 'POST' ? { 'Content-Type': 'application/json' } : {};\n        try {\n            const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {\n                body: JSON.stringify(body),\n                headers,\n                method,\n            });\n            let result;\n            if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n                result = (await response.json()).data;\n            }\n            else {\n                result = (await response.text());\n            }\n            if (!response.ok) {\n                error = new HttpRequestError({\n                    body,\n                    details: result?.error\n                        ? stringify(result.error)\n                        : response.statusText,\n                    headers: response.headers,\n                    status: response.status,\n                    url,\n                });\n                continue;\n            }\n            if (!isHex(result)) {\n                error = new OffchainLookupResponseMalformedError({\n                    result,\n                    url,\n                });\n                continue;\n            }\n            return result;\n        }\n        catch (err) {\n            error = new HttpRequestError({\n                body,\n                details: err.message,\n                url,\n            });\n        }\n    }\n    throw error;\n}\n//# sourceMappingURL=ccip.js.map"],"names":["OffchainLookupError","callbackSelector","cause","data","extraData","sender","urls","url","OffchainLookupResponseMalformedError","result","stringify","OffchainLookupSenderMismatchError","to","offchainLookupSignature","offchainLookupAbiItem","offchainLookup","client","blockNumber","blockTag","args","decodeErrorResult","callData","ccipRead","ccipRequest_","ccipRequest","isAddressEqual","data_","call","concat","encodeAbiParameters","err","error","Error","i","method","body","undefined","headers","response","fetch","JSON","isHex"],"mappings":"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"}